% conclusion.tex
\documentclass[dareport.tex]{subfiles}
\begin{document}
% Content here
\section{Conclusion}

Traditionally when we design and use algorithms, the expectation is to run that algorithm in a single process/node or if it is a concurrent algorithm, to run it in a multi-threaded environment. However in present days, due to the ample availability of resources, distributed computing systems have become a significant part in fulfilling computational requirements of many organizations. In contrast to single process/node systems, distributed systems contain multiple heterogeneous/homogeneous nodes which are connected to each other via a network. Therefore when working with distributed systems, in order to coordinate the activities to achieve the expected results, various distributed algorithms are required. As a requirement of the COMP90020 - Distributed Algorithms course module, we have implemented a Distributed Multi-Server Chat System --- codename Strike --- and we have utilised this opportunity to not only to implement multiple distributed algorithms proposed in various peer-reviewed research publications, but we have also combined these algorithms to achieve reliable failure detection, leadership election and distributed consensus.

The designing of a distributed algorithm involves extensive consideration on communication protocols as part of the algorithm. And in order to acquire the expected results from the system, this communication via the interconnected network is vital. Multicast, Broadcast or Unicast communication patterns are extensively being used for this purpose in various distributed applications. So in Strike, we have implemented a peer-to-peer communication protocol on top of TCP/IP and implemented a broadcast communication overlay on top of that for all the communication purposes.

From a distributed algorithms perspective, we have implemented three main algorithms. First algorithm is Gossip based failure detection. Failure detection is a critical aspect in a distributed system where nodes tend fail often. As opposed to the Naive approach in sending a heartbeat to every node, we have implemented a robust and efficient gossip based information sharing to detect whether a node can be suspected to have failed. The communication of the gossip-type protocol solves the problem of message explosion in Naive approach and reduces the complexity from $ O(n^2) $ to $ O(n) $.

Next we have implemented a leadership election algorithm to elect a leader for the distributed system. Since node failure is an inherent part of distributed systems, we have chosen two bully based leader election algorithms which are fault tolerant. In Strike we have implemented the inefficient but simple, Bully Algorithm and complex but efficient, Fast-Bully algorithm and only either one of them can be configured to run in the system. As opposed to the message complexity of $ O(n^2) $ in Bully Algorithm, the Fast Bully algorithm is only $ O(n) $. We use the elected coordinator for distributed consensus which is the final distributed algorithm we have implemented.

When the elected leader in the Strike system suspects another node to have failed using our Gossip-based failure detection system, instead of simply disowning that node, we turn to a democratic approach. Therefore the leader begins a distributed consensus process to ask every member in the system (including the suspected node), whether they would like the suspected node to be removed. Therefore if all the nodes (or most of the nodes) believe that the suspect has indeed failed, it can be removed and vice versa. Since we are following a consensus based approach, even if there were byzantine members in the system, the system will function correctly as expected.

In our final experimentation deployment on Strike System with 4 server-nodes cluster setup, we observed the eventual consistency of how these algorithms work together to reach reliable, fault-tolerant, consistent state. This is indeed a fascinating finding for us to observe how multiple distributed algorithms are orchestrated to work together to achieve an end result. The fact that these algorithms require timed-intervals and timeout values made us aware that even though in most cases the timeout values do not affect the accuracy of the end result, they indeed affect the performance of the system. We also believe that the same orchestration of multiple algorithms and the approach we have taken, can be utilised in other types of distributed applications development such as database clusters, data replication servers, distributed game systems and so on.

By attempting on developing the chosen set of distributed algorithms --- Failure Detection, Leader Election, and Consensus as well as the choice of Strike Chat Messaging Application --- we believe we have achieved the intended learning objectives of this project and have been able to demonstrate that we have implemented the chosen algorithms in a most realistic setting.


\end{document}